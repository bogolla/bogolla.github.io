<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Frontend Sprint</title>
    <link rel="stylesheet" href="../assets/styles/chapter10-12.css" />
    <link rel="stylesheet" href="assets/styles/navbar.css" />
  </head>
  <body>
    <div id="header">
      <header>
        <h1>Header</h1>
      </header> 
    </div>
    <div id="sidebar">
      <header>
        <h1>Sidebar</h1>
      </header> 
    </div>
    <div id="main">
      <header>
        <h1>Main Content Area</h1>
      </header>  
      <p>Floating and positioning are very compelling features of CSS. They’re also likely to
be an exercise in frustration if you’re careless in how you use them. Element overlap-
ping, stacking order, size, and placement all have to be considered carefully when
elements are positioned, and floated elements’ relation to the normal flow must also
be taken into account. Creating layouts using floating and positioning can thus take
some adjustment, but the rewards are well worth the price.
While it’s true that a great deal of layout can thus be freed of tables, there are still
reasons to use tables on the Web, such as presenting stock quotes or sports scores,
among others. In the next chapter, we’ll examine how CSS has grown to address the
question of table layout.</p>
      <table>
        <tr>
        <td id="r1c1">
        <div>
        The contents of this cell are top-aligned.
        </div>
        </td>
        <td id="r1c2">
        <div>
        The contents of this cell are middle-aligned.
        </div>
        </td>
        <td id="r1c3">
        <div>
        The contents of this cell are bottom-aligned.
        </div>
        </td>
        </tr>
        </table>

        <table class="second">
        <colgroup>
        <col id="c1a"><col id="c2a"><col id="c3a"><col id="c4a">
        </colgroup>
        <tr>
        <td id="r1c1a">1-1</td><td id="r1c2a">1-2</td>
        <td id="r1c3a">1-3</td><td id="r1c4a">1-4</td>
        </tr>
        <tr>
        <td id="r2c1a">2-1</td><td id="r2c2a">2-2</td>
        <td id="r2c3a">2-3</td><td id="r2c4a">2-4</td>
        </tr>
        <tr>
        <td id="r3c1a">3-1</td><td id="r3c2a">3-2</td>
        <td id="r3c3a">3-3</td><td id="r3c4a">3-4</td>
        </tr>
        <tr>
        <td id="r4c1a">4-1</td><td id="r4c2a">4-2</td>
        <td id="r4c3a">4-3</td><td id="r4c4a">4-4</td>
        </tr>
        </table>
        <p>Floating and positioning are very compelling features of CSS. They’re also likely to be an exercise in frustration if you’re careless in how you use them. Element overlap- ping, stacking order, size, and placement all have to be considered carefully when elements are positioned, and floated elements’ relation to the normal flow must also be taken into account. Creating layouts using floating and positioning can thus take some adjustment, but the rewards are well worth the price. While it’s true that a great deal of layout can thus be freed of tables, there are still reasons to use tables on the Web, such as presenting stock quotes or sports scores, among others. In the next chapter, we’ll examine how CSS has grown to address the question of table layout.</p>
        <p>
          Z-index seems so simple: elements with a higher z-index are stacked in front of elements with a lower z-index, right? Well, actually, no. This is part of the problem with z-index. It appears so simple, so most developers don’t take the time to read the rules.
          Every element in an HTML document can be either in front of or behind every other element in the document. This is known as the stacking order. The rules to determine this order are pretty clearly defined in the spec, but as I’ve already stated, they’re not fully understood by most developers.
          When the z-index and position properties aren’t involved, the rules are pretty simple: basically, the stacking order is the same as the order of appearance in the HTML. (OK, it’s actually a little more complicated than that, but as long as you’re not using negative margins to overlap inline elements, you probably won’t encounter the edge cases.)
          When you introduce the position property into the mix, any positioned elements (and their children) are displayed in front of any non-positioned elements. (To say an element is “positioned” means that it has a position value other than static, e.g., relative, absolute, etc.)
          Finally, when z-index is involved, things get a little trickier. At first it’s natural to assume elements with higher z-index values are in front of elements with lower z-index values, and any element with a z-index is in front of any element without a z-index, but it’s not that simple. First of all, z-index only works on positioned elements. If you try to set a z-index on an element with no position specified, it will do nothing. Secondly, z-index values can create stacking contexts, and now suddenly what seemed simple just got a lot more complicated.
        </p>
    </div>
    <div id="footer">
        <p>@bogolla</p>
    </div>>
 </body>
</html>
